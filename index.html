<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="GUM -> WebCodecs -> WebCrypto -> MSE/EME-for-WebCodecs">
    <meta name="keywords" content="eme, mse, webcodecs, eme-for-webcodecs, mse-for-webcodecs">
    <title>WebCodecs + MSE/EME-for-WebCodecs demo</title>
</head>

<body>
<div style="height:75vh;width:95vw">
    <video height="100%" width="100%" controls autoplay id="video"></video>
</div>
<br>
<table>
    <tr>
        <td style="text-align:right">Codec:</td>
        <td style="text-align:left">
            <select style="width:fit-content" id="codec-slct">
                <option>VP8</option>
                <option>VP9</option>
                <option selected>AV1</option>
                <option>H264</option>
                <option>HEVC</option>
            </select>
        </td>
    </tr>
</table>
<br>
<button id="start-stop-btn">Start</button>
<br>
<a href="https://github.com/vitaly-castLabs/eme-for-webcodecs" target=”_blank” style="position:fixed;bottom:8px;left:8px">GitHub</a>
<script>

const video = document.getElementById('video')
const startBtn = document.getElementById('start-stop-btn')
const codecSlct = document.getElementById('codec-slct')

const codecMap = {
    VP8: 'vp8',
    VP9: 'vp09.00.10.08',
    AV1: 'av01.0.05M.08',
    H264: 'avc1.420032',
    HEVC: 'hev1.1.6.L93.B0'
}

const testKey = new Uint8Array([0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c])
const testKeyId = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01])
const testIv = new Uint8Array([0xd5, 0xfb, 0xd6, 0xb8, 0x2e, 0xd9, 0x3e, 0x4e, 0xf9, 0x8a, 0xe4, 0x09, 0x31, 0xee, 0x33, 0xb7])

let cryptoKey = null

let state = 'stopped'

let queue = []

let mediaSource = null
let sourceBuffer = null

const base64urlEncode = (bytes) =>
    btoa(String.fromCharCode(...bytes))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/g, '')

function setupMse() {
    mediaSource = new MediaSource()
    video.src = URL.createObjectURL(mediaSource)
    mediaSource.addEventListener('sourceopen', () => {
        mediaSource.duration = Number.POSITIVE_INFINITY    // this is a Safari thing, adding just in case
        const codec = codecMap[codecSlct.value]
        URL.revokeObjectURL(video.src)
        sourceBuffer = mediaSource.addSourceBuffer({videoConfig: {codec, encryptionScheme: 'cenc'}})
    })
}

async function setupEme() {
    const keySystem = 'org.w3.clearkey'
    const codec = codecMap[codecSlct.value]
    const config = [{
        initDataTypes: ['keyids'],
        videoCapabilities: [{contentType: `video/mp4;codecs="${codec}"`, encryptionScheme: 'cenc'}]
    }]

    const keySystemAccess = await navigator.requestMediaKeySystemAccess(keySystem, config)
    const mediaKeys = await keySystemAccess.createMediaKeys()
    await video.setMediaKeys(mediaKeys)

    const keySession = video.mediaKeys.createSession()
    keySession.addEventListener('message', (event) => {
        const request = JSON.parse(new TextDecoder().decode(event.message))
        console.log('Received license request:', request)
        const license = {
            keys: [{
                kty: 'oct',
                alg: 'A128KW',
                kid: request.kids[0],
                k: base64urlEncode(testKey)
            }]
        }
        const licenseBuffer = new TextEncoder().encode(JSON.stringify(license))
        event.target.update(licenseBuffer)
    })

    const encoder = new TextEncoder()
    const initData = encoder.encode(JSON.stringify({'kids': [base64urlEncode(testKeyId)]}))
    await keySession.generateRequest('keyids', initData)
}

let startTimestamp = -1
async function handleChunk(chunk, metadata) {
    const encodedFrame = new ArrayBuffer(chunk.byteLength)
    chunk.copyTo(encodedFrame)
    let encryptedChunkData = await window.crypto.subtle.encrypt(
        {name: 'AES-CTR', counter: testIv, length: 128},
        cryptoKey,
        encodedFrame)

    if (startTimestamp < 0)
        startTimestamp = chunk.timestamp

    const encryptedChunk = new EncodedVideoChunk({
        type: chunk.type,
        timestamp: chunk.timestamp - startTimestamp,
        // just put some arbitrary large value here, apparently the most important thing is that
        // there are no time gaps, when timestamp and duration are added up (overlapping seems to
        // be ok with Chrome).
        duration: 1_000_000, //chunk.duration,   // this is always 0
        data: encryptedChunkData,
        decryptConfig: {
            encryptionScheme: 'cenc',
            keyId: testKeyId,
            initializationVector: testIv,
            subsampleLayout: [{clearBytes: 0, cypherBytes: encryptedChunkData.byteLength}]
        }
    })
    queue.push(encryptedChunk)

    while (sourceBuffer && !sourceBuffer.updating && queue.length > 0) {
        const encryptedFrame = queue.shift()
        if (encryptedFrame.type === 'key')
            console.log('Appending key frame,', encryptedFrame.byteLength, 'bytes, ts:', encryptedFrame.timestamp / 1_000_000)

        sourceBuffer.appendEncodedChunks(encryptedFrame)
    }
}

async function startStop() {
    if (state === 'running') {
        state = 'stopped'
        return
    }

    if (!cryptoKey)
        cryptoKey = await crypto.subtle.importKey('raw', testKey.buffer, 'AES-CTR', false, ['encrypt', 'decrypt'])

    try {
        setupMse()
        await setupEme()
    } catch (error) {
        alert(`Failed to initialize ClearKey DRM: ${error}`)
        state = 'stopped'
        startBtn.textContent = 'Start'
        video.src = ''
        return
    }

    let stream = null
    let trackProcessor = null
    let videoEncoder = null
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {width: {ideal: 640}, height: {ideal: 480}, frameRate: {ideal: 10}}
        })
        trackProcessor = new MediaStreamTrackProcessor({track: stream.getVideoTracks()[0]})
        videoEncoder = new VideoEncoder({
            output: handleChunk,
            error: e => {alert(e.message)}
        })
    }
    catch (e) {
        stream?.getTracks().forEach(t => t.stop())
        alert(e.message)
        return
    }

    if (!videoEncoder)
        return

    const reader = trackProcessor.readable.getReader()

    state = 'running'
    startBtn.textContent = 'Stop'

    video.play().then(() => {}).catch(() => {})

    const keyFrameFreq = 100
    let frameCount = keyFrameFreq + 1
    while (state === 'running') {
        const { done, value } = await reader.read()

        if (done)
            break

        if (videoEncoder.state === 'unconfigured') {
            const codec = codecMap[codecSlct.value]
            const config = {
                codec,
                width: value.codedWidth,
                height: value.codedHeight,
                latencyMode: 'realtime',
                avc: {format: 'annexb'},
                hevc: {format: 'annexb'}
            }
            console.log('Video encoder config:', config)
            videoEncoder.configure(config)
        }

        // enforce a key frame every now and then
        const options = {keyFrame: (frameCount > keyFrameFreq)}
        videoEncoder.encode(value, options)
        value.close()

        if (options.keyFrame)
            frameCount = 0
        else
            frameCount++
    }

    video.src = ''
    startTimestamp = -1
    startBtn.textContent = 'Start'

    stream?.getTracks().forEach(t => t.stop())
}

window.onload = function() {
    if (!SourceBuffer.prototype.hasOwnProperty('appendEncodedChunks')) {
        alert('appendEncodedChunks is not supported by the browser! Use Chrome and make sure Experimental Web Platform features are enabled in chrome://flags')
        return
    }

    startBtn.addEventListener('click', startStop, false)
    video.playoutDelayHint = video.jitterBufferDelayHint = video.jitterBufferTarget = 0
}
</script>
</body>
</html>
